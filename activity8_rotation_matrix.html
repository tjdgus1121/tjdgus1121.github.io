<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- üîç SEO (Í≤ÄÏÉâÏóîÏßÑ ÏµúÏ†ÅÌôî) -->
    <meta name="description" content="ÌöåÏ†Ñ ÌñâÎ†¨Ïùò Í∞úÎÖêÏùÑ Î∞∞Ïö∞Í≥† Ï†êÏù¥ ÌöåÏ†ÑÌï† Îïå Ï¢åÌëúÍ∞Ä Ïñ¥ÎñªÍ≤å Î≥ÄÌôòÎêòÎäîÏßÄ ÏãúÍ∞ÅÏ†ÅÏúºÎ°ú ÌÉêÍµ¨Ìï©ÎãàÎã§. Í∞ÅÎèÑÎ•º Î≥ÄÍ≤ΩÌïòÎ©∞ ÌöåÏ†Ñ Î≥ÄÌôòÏùÑ ÏßÅÏ†ë Ï≤¥ÌóòÌï¥ Î≥¥ÏÑ∏Ïöî.">
    <meta name="keywords" content="ÌöåÏ†Ñ ÌñâÎ†¨, Í∏∞Ìïò Î≥ÄÌôò, ÏÑ†ÌòïÎåÄÏàò, Ï†ê ÌöåÏ†Ñ, ÏàòÌïô ÏãúÍ∞ÅÌôî, ÍµêÏú°Ïö© ÌôúÎèô, ÌñâÎ†¨ Î≥ÄÌôò, Í∞ÅÎèÑ Î≥ÄÌôò">
    <meta name="author" content="Ìô©ÏÑ±ÌòÑ">
    <meta name="google-site-verification" content="s7dTY3TNe-PjxGrl--MTPXDXJcgD2V7_6MDZ4SoEDP8" />
    <meta name="naver-site-verification" content="c020330e12eea0ae1a607097941a61b11590df69" />

    <!-- üì± SNS Í≥µÏú† (Open Graph) -->
    <meta property="og:title" content="ÌöåÏ†Ñ ÌñâÎ†¨ ÌÉêÍµ¨ - Ïù∏Í≥µÏßÄÎä• ÏàòÌïô ÌôúÎèô">
    <meta property="og:description" content="Ï†êÏù¥ ÌöåÏ†Ñ ÌñâÎ†¨Ïóê ÏùòÌï¥ Ïñ¥ÎñªÍ≤å Î≥ÄÌôòÎêòÎäîÏßÄ ÏãúÍ∞ÅÏ†ÅÏúºÎ°ú Î≥¥Ïó¨Ï£ºÎäî Ïù∏ÌÑ∞ÎûôÌã∞Î∏å ÌôúÎèô ÌéòÏù¥ÏßÄÏûÖÎãàÎã§.">
    <meta property="og:image" content="https://tjdgus1121.github.io/thumbnail.png">
    <meta property="og:url" content="https://tjdgus1121.github.io/activity8_rotation_matrix.html">
    <meta property="og:type" content="website">

    <!-- üîç SEO (Ï∂îÍ∞Ä Î©îÌÉÄÎç∞Ïù¥ÌÑ∞) -->
    <meta name="robots" content="index, follow">
    <link rel="canonical" href="https://tjdgus1121.github.io/activity8_rotation_matrix.html">

    <!-- Twitter Card -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="ÌöåÏ†Ñ ÌñâÎ†¨ ÌÉêÍµ¨">
    <meta name="twitter:description" content="Ï†êÏù¥ ÌöåÏ†Ñ ÌñâÎ†¨Ïóê ÏùòÌï¥ Ïñ¥ÎñªÍ≤å Î≥ÄÌôòÎêòÎäîÏßÄ Ïù∏ÌÑ∞ÎûôÌã∞Î∏åÌïòÍ≤å Î∞∞Ïö∞Îäî ÏàòÌïô ÍµêÏú° ÌôúÎèô.">
    <meta name="twitter:image" content="https://tjdgus1121.github.io/thumbnail.png">

    <meta name="subject" content="AI ÏàòÌïô ÍµêÏú° Ï≤¥Ìóò">
    <meta name="theme-color" content="#ff9a9e">
    <meta name="copyright" content="Ìô©ÏÑ±ÌòÑ">
    <meta name="reply-to" content="tjdgus1121@naver.com">
    <meta name="url" content="https://tjdgus1121.github.io/activity8_rotation_matrix.html">

    <title>ÌöåÏ†Ñ ÌñâÎ†¨ ÌÉêÍµ¨</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.8.0/math.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css"
        integrity="sha512-Evv84Mr4kqVGRNSgIGL/F/aIDqQb7xQ2vcrdIwxfjThSH8CSR7PBEakCr51Ck+w+/U6swU2Im1vVX0SVk9ABhg=="
        crossorigin="anonymous" referrerpolicy="no-referrer" />
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Do+Hyeon&family=Jua&family=Nanum+Pen+Script&family=Noto+Sans+KR:wght@100..900&family=Orbitron:wght@400..900&display=swap"
        rel="stylesheet">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Gamja+Flower&display=swap" rel="stylesheet">
    <link rel="shortcut icon" href="./favicon.ico" type="image/x-icon">
    <link rel="stylesheet" href="stylefooter.css">
    <style>
        body {
            font-family: 'Noto Sans KR', sans-serif;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            background-color: #f0f2f5;
            background-image:
                linear-gradient(rgba(255, 255, 255, 0.5) 1px, transparent 1px),
                linear-gradient(90deg, rgba(255, 255, 255, 0.5) 1px, transparent 1px);
            background-size: 20px 20px;
            padding: 20px;
        }

        .container {
            text-align: center;
            background: linear-gradient(-45deg,
                    rgba(224, 230, 255, 0.4),
                    rgba(192, 224, 255, 0.4),
                    rgba(216, 240, 240, 0.5),
                    rgba(224, 255, 255, 0.6));
            background-size: 300% 300%;
            animation: gradient-shift 8s ease infinite;
            padding: 2rem;
            border-radius: 30px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.15);
            max-width: 1200px;
            width: 100%;
            position: relative;
            overflow: hidden;
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            justify-content: center;
            align-items: flex-start;
        }

        @keyframes gradient-shift {
            0% {
                background-position: 0% 50%;
            }

            50% {
                background-position: 100% 50%;
            }

            100% {
                background-position: 0% 50%;
            }
        }

        h1 {
            color: #2c3e50;
            margin-bottom: 1.5rem;
            font-size: 3rem;
            width: 100%;
            text-align: center;
            font-family: 'Do Hyeon', sans-serif;
            line-height: 1.3;
            letter-spacing: 0.05em;
        }

        h3 {
            color: #34495e;
            margin: 1rem 0;
            font-size: 1.3rem;
            width: 100%;
            text-align: center;
        }

        .notification {
            padding: 10px;
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
            border-radius: 4px;
            margin-bottom: 10px;
            display: none;
            width: 100%;
            text-align: center;
        }

        .coordinate-system {
            width: 600px;
            height: 600px;
            max-width: 100%;
            aspect-ratio: 1 / 1;
            background: white;
            border: 1px solid #ccc;
            position: relative;
            flex-shrink: 0;
            flex-grow: 0;
        }

        #coordinate-plane {
            width: 100%;
            height: 100%;
            cursor: crosshair;
        }

        .controls {
            flex: 1;
            min-width: 300px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            background-color: rgba(255, 255, 255, 0.9);
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .input-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .angle-inputs {
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
        }

        .angle-inputs>div {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .angle-inputs input[type="number"] {
            width: 100px;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 5px;
            font-size: 1rem;
        }

        button {
            padding: 12px 20px;
            background-color: #3498db;
            /* Blue color */
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            transition: background-color 0.2s ease, transform 0.2s ease;
        }

        button:hover {
            background-color: #2980b9;
            transform: translateY(-2px);
        }

        button:active {
            transform: translateY(0);
        }

        #clear-btn {
            background-color: #e74c3c;
            /* Red color */
        }

        #clear-btn:hover {
            background-color: #c0392b;
        }

        .math-area,
        .vector-info {
            margin-top: 0;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 4px;
            background-color: #f9f9f9;
        }

        table {
            border-collapse: collapse;
            width: 100%;
            margin-top: 20px;
            border-radius: 8px;
            overflow: hidden;
            /* Ensure rounded corners apply to children */
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        table th,
        table td {
            border: 1px solid #ddd;
            padding: 10px;
            text-align: center;
        }

        table th {
            background-color: #f2f2f2;
            font-weight: bold;
        }

        table tbody tr:nth-child(even) {
            background-color: #fefefe;
        }

        table tbody tr:hover {
            background-color: #e9e9e9;
        }

        .vector-info {
            display: flex;
            flex-direction: column;
            gap: 10px;
            align-items: center;
            text-align: center;
        }

        .vector-item {
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .vector-color {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            flex-shrink: 0;
        }

        .axis-label {
            position: absolute;
            font-size: 12px;
            font-weight: bold;
            color: #333;
            /* Ensure axis labels are visible on white background */
        }

        @media (max-width: 768px) {
            .container {
                flex-direction: column;
                align-items: center;
            }

            .coordinate-system {
                width: 100%;
                /* Make it fluid on small screens */
                height: auto;
            }

            .controls {
                width: 100%;
                min-width: auto;
            }

            .angle-inputs {
                flex-direction: column;
                align-items: flex-start;
            }

            .angle-inputs>div {
                width: 100%;
                justify-content: space-between;
            }

            .angle-inputs input[type="number"] {
                width: 150px;
                /* Adjust width for better mobile input */
            }
        }
    </style>
</head>

<body>
    <h1>Î≤°ÌÑ∞ ÌöåÏ†Ñ Í≥ÑÏÇ∞Í∏∞</h1>
    <div class="notification" id="notification">
        ÌÅ¥Î¶≠ÌïòÏó¨ Î≤°ÌÑ∞Ïùò ÎÅùÏ†êÏùÑ Ï†ïÏùòÌï¥Ï£ºÏÑ∏Ïöî. ÏãúÏûëÏ†êÏùÄ ÏõêÏ†ê(0,0)ÏûÖÎãàÎã§.
    </div>

    <div class="container">
        <div class="coordinate-system">
            <canvas id="coordinate-plane"></canvas>
        </div>

        <div class="controls">
            <div class="input-group">
                <label>ÌöåÏ†ÑÍ∞Å ÏûÖÎ†•:</label>
                <div class="angle-inputs">
                    <div>
                        <input type="number" id="degree-input" placeholder="ÎèÑ(¬∞)" title="ÌöåÏ†Ñ Í∞ÅÎèÑ ÏûÖÎ†•">
                        <label>ÎèÑ(¬∞)</label>
                    </div>
                    <div>
                        <span>ÎòêÎäî</span>
                    </div>
                    <div>
                        <input type="number" id="radian-input" placeholder="ÎùºÎîîÏïà" step="0.01" title="ÌöåÏ†Ñ Í∞ÅÎèÑ ÏûÖÎ†•">
                        <label>ÎùºÎîîÏïà(rad)</label>
                    </div>
                </div>
            </div>
            <div style="margin-bottom:10px; text-align:left;">
                <input type="checkbox" id="snap-to-grid" checked>
                <label for="snap-to-grid">Í≤©ÏûêÏ†êÏóê ÎßûÏ∂îÍ∏∞</label>
            </div>

            <button id="rotate-btn">ÌöåÏ†Ñ Ïã§Ìñâ</button>
            <button id="clear-btn">Î™®Îëê ÏßÄÏö∞Í∏∞</button>

            <div class="vector-info" id="vector-info">
                <h3>Î≤°ÌÑ∞ Í∞í</h3>
                <!-- ÎèôÏ†ÅÏúºÎ°ú Î≤°ÌÑ∞ Ï†ïÎ≥¥ ÏÇΩÏûÖ -->
            </div>

            <div class="math-area" id="math-area">
                <h3>ÌöåÏ†Ñ ÌñâÎ†¨ Í≥ÑÏÇ∞</h3>
                <div id="matrix-math"></div>
            </div>
        </div>
    </div>

    <div>
        <h3>Ï¢åÌëú Îç∞Ïù¥ÌÑ∞</h3>
        <table id="data-table">
            <thead>
                <tr>
                    <th>ÌöåÏ†Ñ Î≤àÌò∏</th>
                    <th>Ï¥àÍ∏∞ Ï¢åÌëú (x, y)</th>
                    <th>ÌöåÏ†ÑÍ∞Å</th>
                    <th>ÌöåÏ†Ñ ÌñâÎ†¨</th>
                    <th>ÌöåÏ†Ñ ÌõÑ Ï¢åÌëú (x', y')</th>
                </tr>
            </thead>
            <tbody>
                <!-- ÎèôÏ†ÅÏúºÎ°ú ÌöåÏ†Ñ Í≤∞Í≥º ÏÇΩÏûÖ -->
            </tbody>
        </table>
    </div>

    <footer class="footer" style="width:100%;">
        <div class="footer-content">
            <div>
                <div class="footer-logo">Ïù∏Í≥µÏßÄÎä• ÏàòÌïô Ïù¥ÎØ∏ÏßÄ ÌÉêÍµ¨ ÌôúÎèô ÏÇ¨Ïù¥Ìä∏</div>
                <div class="creator-info">
                    Designed & Developed by <span>Ìô©ÏÑ±ÌòÑ</span><br>
                    Contact : tjdgus1121@naver.com
                </div>
            </div>

            <div class="social-links">
                <a href="mailto:tjdgus1121@naver.com" id="email-link"><i class="fa-solid fa-envelope"></i></a>
                <a href="https://mail.naver.com/write/popup?to=tjdgus1121@naver.com" target="_blank" rel="noopener">
                    <img src="naver.png" alt="Î©îÏùº Î≥¥ÎÇ¥Í∏∞"
                        style="height:25px; filter: grayscale(100%); transition: filter 0.3s;"
                        onmouseover="this.style.filter='grayscale(0%)';"
                        onmouseout="this.style.filter='grayscale(100%)';">
                </a>
            </div>

            <div class="copyright">
                Ïù¥ ÏÇ¨Ïù¥Ìä∏Ïùò Î™®Îì† ÏΩòÌÖêÏ∏†Îäî Ï†ïÏÑ±Íªè ÎßåÎì† Ï†ÄÏûëÎ¨ºÏûÖÎãàÎã§. ‚ìí <span id="current-year"></span><br>
                Îã§Îßå, Ïù∏Í≥µÏßÄÎä• ÏàòÌïô ÍµêÏú°ÏùÑ Ìï®Íªò Í≥†ÎØºÌïòÎäî Î™®Îì† ÏÑ†ÏÉùÎãòÎì§Íªò ÎèÑÏõÄÏù¥ ÎêòÍ∏∞Î•º Î∞îÎûçÎãàÎã§.
            </div>

    </footer>

    <script>
        // Main variables
        const canvas = document.getElementById('coordinate-plane');
        const ctx = canvas.getContext('2d');
        const degreeInput = document.getElementById('degree-input');
        const radianInput = document.getElementById('radian-input');
        const rotateBtn = document.getElementById('rotate-btn');
        const clearBtn = document.getElementById('clear-btn');
        const vectorInfo = document.getElementById('vector-info');
        const matrixMath = document.getElementById('matrix-math');
        const dataTable = document.getElementById('data-table').getElementsByTagName('tbody')[0];
        const notification = document.getElementById('notification');

        let vectors = [];
        let vectorColors = [
            '#3498db', '#e74c3c', '#2ecc71', '#9b59b6',
            '#f1c40f', '#1abc9c', '#e67e22', '#34495e'
        ];

        // ÌÖåÏù¥Î∏îÏóê Í∏∞Î°ùÌï† ÌöåÏ†Ñ Ïù¥Î†•ÏùÑ Ï†ÄÏû•Ìï† Î∞∞Ïó¥
        let rotationHistory = [];

        // Coordinate system parameters
        const scale = 30; // 30px = 1 unit
        let offsetX, offsetY;

        // Initialize the canvas
        function initCanvas() {
            // Set canvas size to match its container
            // Set canvas size to be a square based on the parent's width
            const parentWidth = canvas.parentElement.clientWidth;

            canvas.width = parentWidth;
            canvas.height = parentWidth; // Ensure height is equal to width

            // Calculate the center of the canvas
            offsetX = canvas.width / 2;
            offsetY = canvas.height / 2;

            drawCoordinateSystem();
            notification.style.display = 'block';
        }

        // Draw the coordinate system with grid and axes
        function drawCoordinateSystem() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw grid lines
            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 1;

            // Vertical grid lines
            for (let x = -Math.floor(offsetX / scale); x <= Math.floor(offsetX / scale); x++) {
                if (x === 0) continue; // Skip the origin line, we'll draw it separately
                const canvasX = offsetX + x * scale;
                ctx.beginPath();
                ctx.moveTo(canvasX, 0);
                ctx.lineTo(canvasX, canvas.height);
                ctx.stroke();

                // Add x-axis labels
                ctx.fillStyle = 'black';
                ctx.font = '12px Arial';
                ctx.fillText(x.toString(), canvasX - 5, offsetY + 15);
            }

            // Horizontal grid lines
            for (let y = -Math.floor(offsetY / scale); y <= Math.floor(offsetY / scale); y++) {
                if (y === 0) continue; // Skip the origin line, we'll draw it separately
                const canvasY = offsetY - y * scale;
                ctx.beginPath();
                ctx.moveTo(0, canvasY);
                ctx.lineTo(canvas.width, canvasY);
                ctx.stroke();

                // Add y-axis labels
                ctx.fillStyle = 'black';
                ctx.font = '12px Arial';
                ctx.fillText(y.toString(), offsetX - 15, canvasY + 5);
            }

            // Draw x and y axes
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 2;

            // x-axis
            ctx.beginPath();
            ctx.moveTo(0, offsetY);
            ctx.lineTo(canvas.width, offsetY);
            ctx.stroke();

            // y-axis
            ctx.beginPath();
            ctx.moveTo(offsetX, 0);
            ctx.lineTo(offsetX, canvas.height);
            ctx.stroke();

            // Draw axis labels
            ctx.fillStyle = 'black';
            ctx.font = 'bold 16px Arial';
            ctx.fillText('x', canvas.width - 15, offsetY - 10);
            ctx.fillText('y', offsetX + 10, 15);
            ctx.fillText('O', offsetX - 15, offsetY + 15); // Origin label

            // Draw all vectors
            vectors.forEach(vector => {
                drawVector(vector.x, vector.y, vector.color);
                if (vector.rotated) {
                    drawVector(vector.rotatedX, vector.rotatedY, vector.rotatedColor);
                }
            });
        }

        // Draw a vector from origin (0,0) to (x,y)
        function drawVector(x, y, color) {
            const canvasX = offsetX + x * scale;
            const canvasY = offsetY - y * scale;

            ctx.strokeStyle = color;
            ctx.lineWidth = 2;

            // Draw the line from origin
            ctx.beginPath();
            ctx.moveTo(offsetX, offsetY);
            ctx.lineTo(canvasX, canvasY);
            ctx.stroke();

            // Draw arrowhead
            drawArrowhead(offsetX, offsetY, canvasX, canvasY, color);
        }

        // Draw arrowhead at the end of the vector
        function drawArrowhead(fromX, fromY, toX, toY, color) {
            const headLength = 10;
            const angle = Math.atan2(fromY - toY, fromX - toX);

            ctx.fillStyle = color;

            ctx.beginPath();
            ctx.moveTo(toX, toY);
            ctx.lineTo(
                toX - headLength * Math.cos(angle - Math.PI / 6),
                toY - headLength * Math.sin(angle - Math.PI / 6)
            );
            ctx.lineTo(
                toX - headLength * Math.cos(angle + Math.PI / 6),
                toY - headLength * Math.sin(angle + Math.PI / 6)
            );
            ctx.closePath();
            ctx.fill();
        }

        // Convert canvas coordinates to real coordinates
        function canvasToCoords(canvasX, canvasY) {
            const x = (canvasX - offsetX) / scale;
            const y = -(canvasY - offsetY) / scale;
            return { x: parseFloat(x.toFixed(2)), y: parseFloat(y.toFixed(2)) };
        }

        // Add vector to the list
        function addVector(x, y) {
            const colorIndex = 0; // Ìï≠ÏÉÅ Ï≤´ Î≤àÏß∏ ÏÉâÏÉÅ ÏÇ¨Ïö©
            const rotatedColorIndex = 4; // Ìï≠ÏÉÅ Í≥†Ï†ïÎêú ÏÉâÏÉÅ ÏÇ¨Ïö©

            vectors.push({
                id: 1, // Ìï≠ÏÉÅ IDÎäî 1
                x: x,
                y: y,
                color: vectorColors[colorIndex],
                rotated: false,
                rotatedX: null,
                rotatedY: null,
                rotatedColor: vectorColors[rotatedColorIndex],
                angle: null
            });

            updateVectorInfo();
            drawCoordinateSystem();
        }

        // Update the vector info panel
        function updateVectorInfo() {
            vectorInfo.innerHTML = '<h3>Î≤°ÌÑ∞ Í∞í</h3>';

            if (vectors.length === 0) {
                vectorInfo.innerHTML += '<p>Î≤°ÌÑ∞Í∞Ä ÏóÜÏäµÎãàÎã§. Ï¢åÌëúÌèâÎ©¥ÏùÑ ÌÅ¥Î¶≠ÌïòÏó¨ Î≤°ÌÑ∞Î•º Ï∂îÍ∞ÄÌïòÏÑ∏Ïöî.</p>';
                return;
            }

            vectors.forEach(vector => {
                const item = document.createElement('div');
                item.className = 'vector-item';

                const colorSpan = document.createElement('span');
                colorSpan.className = 'vector-color';
                colorSpan.style.backgroundColor = vector.color;

                const info = document.createElement('span');
                info.textContent = `Ï¥àÍ∏∞ Î≤°ÌÑ∞ Ï¢åÌëú: (${vector.x}, ${vector.y})`;

                item.appendChild(colorSpan);
                item.appendChild(info);

                if (vector.rotated) {
                    const rotatedColorSpan = document.createElement('span');
                    rotatedColorSpan.className = 'vector-color';
                    rotatedColorSpan.style.backgroundColor = vector.rotatedColor;

                    const rotatedInfo = document.createElement('span');
                    rotatedInfo.textContent = `ÌöåÏ†Ñ Í≤∞Í≥º Ï¢åÌëú : (${vector.rotatedX}, ${vector.rotatedY})`;

                    item.appendChild(document.createElement('br'));
                    item.appendChild(rotatedColorSpan);
                    item.appendChild(rotatedInfo);
                }

                vectorInfo.appendChild(item);
            });
        }

        // Rotate a vector using rotation matrix
        function rotateVector(vector, angleRad) {
            const cosTheta = Math.cos(angleRad);
            const sinTheta = Math.sin(angleRad);

            const rotationMatrix = [
                [cosTheta, -sinTheta],
                [sinTheta, cosTheta]
            ];

            const x = vector.x;
            const y = vector.y;

            const rotatedX = rotationMatrix[0][0] * x + rotationMatrix[0][1] * y;
            const rotatedY = rotationMatrix[1][0] * x + rotationMatrix[1][1] * y;

            return {
                x: parseFloat(rotatedX.toFixed(2)),
                y: parseFloat(rotatedY.toFixed(2)),
                matrix: rotationMatrix
            };
        }

        // Update the calculations and table
        function updateCalculations() {
            if (vectors.length === 0) {
                matrixMath.innerHTML = '<p>Î≤°ÌÑ∞Î•º Î®ºÏ†Ä Ï∂îÍ∞ÄÌï¥Ï£ºÏÑ∏Ïöî.</p>';
                return;
            }

            let mathHTML = '';

            const lastVector = vectors[vectors.length - 1];
            if (lastVector.rotated) {
                const angleRad = lastVector.angle;
                const angleDeg = (angleRad * 180 / Math.PI).toFixed(2);

                mathHTML += `<p>ÌöåÏ†ÑÍ∞Å: ${angleDeg}¬∞ = ${angleRad.toFixed(4)} ÎùºÎîîÏïà</p>`;
                mathHTML += `<p>ÌöåÏ†Ñ ÌñâÎ†¨:</p>`;
                mathHTML += `<p>\\begin{pmatrix} \\cos(${angleRad.toFixed(4)}) & -\\sin(${angleRad.toFixed(4)}) \\\\ \\sin(${angleRad.toFixed(4)}) & \\cos(${angleRad.toFixed(4)}) \\end{pmatrix} = \\begin{pmatrix} ${lastVector.matrix[0][0].toFixed(4)} & ${lastVector.matrix[0][1].toFixed(4)} \\\\ ${lastVector.matrix[1][0].toFixed(4)} & ${lastVector.matrix[1][1].toFixed(4)} \\end{pmatrix}</p>`;
                mathHTML += `<p>Í≥ÑÏÇ∞ Í≥ºÏ†ï:</p>`;
                mathHTML += `\\[\\begin{pmatrix} ${lastVector.matrix[0][0].toFixed(4)} & ${lastVector.matrix[0][1].toFixed(4)} \\\\ 
${lastVector.matrix[1][0].toFixed(4)} & ${lastVector.matrix[1][1].toFixed(4)} \\end{pmatrix} \\times \\begin{pmatrix} ${lastVector.x} \\\\ ${lastVector.y} \\end{pmatrix} = \\begin{pmatrix} ${lastVector.rotatedX} \\\\ ${lastVector.rotatedY} \\end{pmatrix}\\]`;
            } else {
                mathHTML = '<p>ÌöåÏ†Ñ Î≤ÑÌäºÏùÑ ÌÅ¥Î¶≠ÌïòÏó¨ Î≤°ÌÑ∞Î•º ÌöåÏ†ÑÌï¥Î≥¥ÏÑ∏Ïöî.</p>';
            }

            matrixMath.innerHTML = mathHTML;

            // Render the LaTeX expressions
            if (window.MathJax) {
                MathJax.typeset([matrixMath]);
            }

            updateDataTable();
        }

        // Update the data table
        function updateDataTable() {
            dataTable.innerHTML = '';

            // ÌöåÏ†Ñ Ïù¥Î†•Ïùò Î™®Îì† Ìï≠Î™©ÏùÑ ÌëúÏãú
            rotationHistory.forEach(rotation => {
                const row = document.createElement('tr');

                const idCell = document.createElement('td');
                idCell.textContent = rotation.id;

                const coordCell = document.createElement('td');
                coordCell.innerHTML = `\\( \\begin{pmatrix} ${rotation.x} \\\\ ${rotation.y} \\end{pmatrix} \\)`;

                const angleCell = document.createElement('td');
                const angleDeg = (rotation.angle * 180 / Math.PI).toFixed(2);
                angleCell.textContent = `${angleDeg}¬∞ (${rotation.angle.toFixed(4)} rad)`;

                const matrixCell = document.createElement('td');
                matrixCell.innerHTML = `\\( \\begin{pmatrix} 
                    ${rotation.matrix[0][0].toFixed(2)} & ${rotation.matrix[0][1].toFixed(2)} \\\\
                    ${rotation.matrix[1][0].toFixed(2)} & ${rotation.matrix[1][1].toFixed(2)}
                \\end{pmatrix} \\)`;

                const resultCell = document.createElement('td');
                resultCell.innerHTML = `\\( \\begin{pmatrix} ${rotation.rotatedX} \\\\ ${rotation.rotatedY} \\end{pmatrix} \\)`;

                row.appendChild(idCell);
                row.appendChild(coordCell);
                row.appendChild(angleCell);
                row.appendChild(matrixCell);
                row.appendChild(resultCell);

                dataTable.appendChild(row);
            });

            // ÌÖåÏù¥Î∏îÏóê LaTeX Ï†ÅÏö©
            if (window.MathJax) {
                MathJax.typeset([dataTable]);
            }
        }

        // Event Listeners
        canvas.addEventListener('click', (event) => {
            const rect = canvas.getBoundingClientRect();
            const canvasX = event.clientX - rect.left;
            const canvasY = event.clientY - rect.top;

            let coords = canvasToCoords(canvasX, canvasY);

            // Í≤©ÏûêÏ†êÏóê ÎßûÏ∂îÍ∏∞ Ï≤¥ÌÅ¨Î∞ïÏä§Í∞Ä Ï≤¥ÌÅ¨ÎêòÏñ¥ ÏûàÏúºÎ©¥ Ï†ïÏàòÎ°ú Î∞òÏò¨Î¶º
            if (document.getElementById('snap-to-grid').checked) {
                coords.x = Math.round(coords.x);
                coords.y = Math.round(coords.y);
            }

            // Ïù¥ÎØ∏ Î≤°ÌÑ∞Í∞Ä ÏûàÎäîÏßÄ ÌôïÏù∏
            if (vectors.length > 0) {
                // Í∏∞Ï°¥ Î≤°ÌÑ∞ ÏÇ≠Ï†úÎ•º ÏÇ¨Ïö©ÏûêÏóêÍ≤å ÏïåÎ¶º
                notification.textContent = "Í∏∞Ï°¥ Î≤°ÌÑ∞Í∞Ä ÏÇ≠Ï†úÎêòÏóàÏäµÎãàÎã§. ÏÉà Î≤°ÌÑ∞Î°ú Ï¥àÍ∏∞ÌôîÌï©ÎãàÎã§.";
                notification.style.display = 'block';

                // Î≤°ÌÑ∞ Î™©Î°ù Ï¥àÍ∏∞Ìôî
                vectors = [];
                // ÌöåÏ†Ñ Ïù¥Î†• Ïú†ÏßÄ (Î≤°ÌÑ∞Î•º Î≥ÄÍ≤ΩÌï¥ÎèÑ Ïù¥Ï†Ñ Í≥ÑÏÇ∞ Í≤∞Í≥ºÎäî Ïú†ÏßÄ)
            } else {
                notification.style.display = 'none';
            }

            // ÏÉà Î≤°ÌÑ∞ Ï∂îÍ∞Ä
            addVector(coords.x, coords.y);
        });

        degreeInput.addEventListener('input', () => {
            if (degreeInput.value) {
                const degrees = parseFloat(degreeInput.value);
                radianInput.value = (degrees * Math.PI / 180).toFixed(4);
            } else {
                radianInput.value = '';
            }
        });

        radianInput.addEventListener('input', () => {
            if (radianInput.value) {
                const radians = parseFloat(radianInput.value);
                degreeInput.value = (radians * 180 / Math.PI).toFixed(2);
            } else {
                degreeInput.value = '';
            }
        });

        // Rotate Î≤ÑÌäº ÌÅ¥Î¶≠ Ïù¥Î≤§Ìä∏ Ìï∏Îì§Îü¨
        rotateBtn.addEventListener('click', () => {
            if (vectors.length === 0) {
                alert("Î≤°ÌÑ∞Î•º Î®ºÏ†Ä Ï∂îÍ∞ÄÌï¥Ï£ºÏÑ∏Ïöî!");
                return;
            }

            if (!degreeInput.value && !radianInput.value) {
                alert("ÌöåÏ†ÑÍ∞ÅÏùÑ ÏûÖÎ†•Ìï¥Ï£ºÏÑ∏Ïöî!");
                return;
            }

            const angleRad = parseFloat(radianInput.value);

            // ÌòÑÏû¨ Î≤°ÌÑ∞ ÏÉÅÌÉú Í∞ÄÏ†∏Ïò§Í∏∞
            const vector = vectors[0]; // Ìï≠ÏÉÅ Ï≤´ Î≤àÏß∏(Ïú†ÏùºÌïú) Î≤°ÌÑ∞

            // ÌöåÏ†Ñ Ï†ÅÏö©
            const result = rotateVector(vector, angleRad);

            // ÌöåÏ†Ñ Ïù¥Î†•Ïóê Ï∂îÍ∞Ä
            rotationHistory.push({
                id: rotationHistory.length + 1,
                x: vector.x,
                y: vector.y,
                angle: angleRad,
                matrix: result.matrix,
                rotatedX: result.x,
                rotatedY: result.y
            });

            // Î≤°ÌÑ∞Ïùò ÌòÑÏû¨ ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏
            vector.rotatedX = result.x;
            vector.rotatedY = result.y;
            vector.matrix = result.matrix;
            vector.angle = angleRad;
            vector.rotated = true;

            updateVectorInfo();
            updateCalculations();
            updateDataTable(); // Îç∞Ïù¥ÌÑ∞ ÌÖåÏù¥Î∏î ÏóÖÎç∞Ïù¥Ìä∏
            drawCoordinateSystem();
        });

        clearBtn.addEventListener('click', () => {
            vectors = [];
            rotationHistory = []; // ÌöåÏ†Ñ Ïù¥Î†•ÎèÑ Ï¥àÍ∏∞Ìôî
            updateVectorInfo();
            matrixMath.innerHTML = '<p>Î≤°ÌÑ∞Î•º Ï∂îÍ∞ÄÌïòÍ≥† ÌöåÏ†ÑÏãúÏºú Í≤∞Í≥ºÎ•º ÌôïÏù∏Ìï¥Î≥¥ÏÑ∏Ïöî.</p>';
            dataTable.innerHTML = '';
            drawCoordinateSystem();
            notification.textContent = "ÌÅ¥Î¶≠ÌïòÏó¨ Î≤°ÌÑ∞Ïùò ÎÅùÏ†êÏùÑ Ï†ïÏùòÌï¥Ï£ºÏÑ∏Ïöî. ÏãúÏûëÏ†êÏùÄ ÏõêÏ†ê(0,0)ÏûÖÎãàÎã§.";
            notification.style.display = 'block';
        });

        // ÌòÑÏû¨ Ïó∞ÎèÑ ÌëúÏãú
        document.getElementById('current-year').textContent = new Date().getFullYear();

        // Initialize the app
        window.addEventListener('load', () => {
            initCanvas();
            updateVectorInfo();
            updateCalculations();
        });

        // Handle window resize
        window.addEventListener('resize', () => {
            initCanvas();
        });
    </script>
</body>

</html>