<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>손글씨 인식 테스트</title>

    <!-- 🔍 SEO (검색엔진 최적화) -->
    <meta name="description" content="손글씨 숫자를 직접 그려 인공지능 모델이 인식하도록 체험하는 활동입니다. AI가 이미지를 어떻게 학습하고 예측하는지 탐구해 보세요.">
    <meta name="keywords" content="손글씨 인식, MNIST, 인공지능 모델, 머신러닝, 딥러닝, AI 체험, 교육용 활동, 숫자 인식, 수학 교육">
    <meta name="author" content="황성현">
    <meta name="google-site-verification" content="s7dTY3TNe-PjxGrl--MTPXDXJcgD2V7_6MDZ4SoEDP8" />
    <meta name="naver-site-verification" content="c020330e12eea0ae1a60707941a61b11590df69" />

    <!-- 📱 SNS 공유 (Open Graph) -->
    <meta property="og:title" content="손글씨 인식 체험 - 인공지능 수학 활동">
    <meta property="og:description" content="사용자가 그린 손글씨 숫자를 인공지능이 인식하는 과정을 직접 체험하고 AI의 작동 방식을 탐구하는 활동 페이지입니다.">
    <meta property="og:image" content="https://tjdgus1121.github.io/thumbnail.png">
    <meta property="og:url" content="https://tjdgus1121.github.io/activity9_mnist_recognizer.html">
    <meta property="og:type" content="website">

    <!-- 🔍 SEO (추가 메타데이터) -->
    <meta name="robots" content="index, follow">
    <link rel="canonical" href="https://tjdgus1121.github.io/activity9_mnist_recognizer.html">
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css"
        integrity="sha512-Evv84Mr4kqVGRNSgIGL/F/aIDqQb7xQ2vcrdIwxfjThSH8CSR7PBEakCr51Ck+w+/U6swU2Im1vVX0SVk9ABhg=="
        crossorigin="anonymous" referrerpolicy="no-referrer" />
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Do+Hyeon&family=Jua&family=Nanum+Pen+Script&family=Noto+Sans+KR:wght@100..900&family=Orbitron:wght@400..900&display=swap"
        rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Gamja+Flower&display=swap" rel="stylesheet">
    <link rel="shortcut icon" href="./favicon.ico" type="image/x-icon">
    <link rel="stylesheet" href="stylefooter.css">

    <!-- Twitter Card -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="손글씨 인식 체험">
    <meta name="twitter:description" content="사용자 손글씨 숫자를 인공지능이 인식하는 교육용 체험 활동.">
    <meta name="twitter:image" content="https://tjdgus1121.github.io/thumbnail.png">

    <meta name="subject" content="AI 수학 교육 체험">
    <meta name="theme-color" content="#ff9a9e">
    <meta name="copyright" content="황성현">
    <meta name="reply-to" content="tjdgus1121@naver.com">
    <meta name="url" content="https://tjdgus1121.github.io/activity9_mnist_recognizer.html">

    <script src="https://cdnjs.cloudflare.com/ajax/libs/tensorflow/4.13.0/tf.min.js"></script>
    <style>
        /* 전역 스타일 */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #a1c4fd 0%, #c2e9fb 100%);
            min-height: 100vh;
            padding: 20px;
        }

        /* 메인 레이아웃 컨테이너 스타일 */
        .main-layout-container {
            display: flex;
            justify-content: center;
            /* 가로 중앙 정렬 */
            align-items: flex-start;
            /* 세로 상단 정렬 (콘텐츠 따라 내려오도록) */
            gap: 40px;
            /* 메인 앱과 이미지 영역 사이 간격 */
            padding: 20px;
            /* 전체 컨테이너 내부 여백 */
            width: 100%;
            /* 부모 너비에 맞춤 */
            max-width: 1200px;
            /* 전체 레이아웃 최대 너비 제한 */
            margin: 0 auto;
            /* 컨테이너 자체를 중앙에 */
            flex-wrap: wrap;
        }

        /* BEM 스타일 적용 */
        .mnist-app {
            background: rgba(255, 255, 255, 0.95);
            -webkit-backdrop-filter: blur(10px);
            /* Safari 지원 */
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 40px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            max-width: 800px;
            width: 100%;
            text-align: center;
            display: flex;
            /* 내부 요소 정렬을 위해 flexbox 사용 */
            flex-direction: column;
            align-items: center;
        }

        .mnist-app__title {
            color: #333;
            margin-bottom: 30px;
            font-size: 3rem;
            letter-spacing: 2px;
            font-family:"Do Hyeon";
            font-weight: 700;
            background: linear-gradient(45deg, #66b5ea, rgb(26, 10, 43), #ac87aa);
            -webkit-background-clip: text;
            -webkit-text-fill-color: rgba(255, 255, 255, 0);
            background-clip: text;
        }
        .mnist-app__title span{
            -webkit-text-fill-color: white;
        }

        .mnist-app__instructions {
            background: rgba(102, 126, 234, 0.1);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 30px;
            border-left: 4px solid #667eea;
            text-align: left;
            /* 지침은 왼쪽 정렬 */
            width: 100%;
            /* 부모 너비에 맞춤 */
        }

        .mnist-app__instructions h3 {
            color: #333;
            margin-bottom: 10px;
            font-size: 1.2rem;
        }

        .mnist-app__instructions p {
            color: #666;
            line-height: 1.6;
        }

        .mnist-app__status {
            margin: 10px 0;
            padding: 10px;
            border-radius: 10px;
            font-weight: 500;
            width: 100%;
            /* 부모 너비에 맞춤1 */
        }

        .mnist-app__status--loading {
            background: rgba(102, 126, 234, 0.1);
            color: #667eea;
        }

        .mnist-app__status--ready {
            background: rgba(34, 197, 94, 0.1);
            color: #16a34a;
        }

        /* 로딩 컨테이너 스타일 */
        .mnist-app__loading-container {
            margin: 20px 0;
            padding: 20px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 15px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            width: 100%;
            /* 부모 너비에 맞춤 */
            max-width: 500px;
            /* 컨테이너 너비 제한 */
        }

        .mnist-app__progress-text {
            text-align: center;
            font-size: 1.1rem;
            color: #333;
            margin: 5px 0;
        }

        .mnist-app__progress-bar {
            width: 100%;
            height: 20px;
            background: #e0e6ed;
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
            position: relative;
        }

        .mnist-app__progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2);
            border-radius: 10px;
            transition: width 0.3s ease;
            width: 0%;
        }

        .mnist-app__loading-spinner {
            width: 40px;
            height: 40px;
            border: 4px solid #f3f3f3;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 10px auto;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        .mnist-app__loading-steps {
            margin-top: 15px;
            padding: 10px;
            background: rgba(102, 126, 234, 0.05);
            border-radius: 8px;
            text-align: left;
            /* 단계 목록 왼쪽 정렬 */
        }

        .mnist-app__step {
            margin: 5px 0;
            padding: 5px;
            border-radius: 5px;
            transition: all 0.3s ease;
        }

        .mnist-app__step--active {
            background: rgba(102, 126, 234, 0.1);
            color: #667eea;
            font-weight: 600;
        }

        .mnist-app__step--completed {
            background: rgba(34, 197, 94, 0.1);
            color: #16a34a;
        }

        .mnist-app__drawing-area {
            display: flex;
            flex-direction: row;
            gap: 20px;
            align-items: flex-start;
            justify-content: center;
            flex-wrap: wrap;
            margin-bottom: 30px;
            width: 100%;
        }

        .drawing-and-debug-wrapper {
            display: flex;
            gap: 30px;
            align-items: flex-start;
            flex-wrap: wrap;
            justify-content: center;
            flex-grow: 1;
        }

        .mnist-app__canvas-container {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .mnist-app__canvas--drawing {
            border: 3px solid #667eea;
            border-radius: 15px;
            cursor: crosshair;
            background: white;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.1);
            transition: transform 0.2s ease;
        }

        .mnist-app__canvas--drawing:hover {
            transform: scale(1.02);
        }

        .mnist-app__controls {
            display: flex;
            gap: 15px;
            margin-top: 20px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .mnist-app__button {
            padding: 12px 24px;
            border: none;
            border-radius: 25px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }

        .mnist-app__button--clear {
            background: linear-gradient(45deg, #ff6b6b, #ee5a24);
            color: white;
        }

        .mnist-app__button--clear:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(255, 107, 107, 0.4);
        }

        .mnist-app__button--predict {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
        }

        .mnist-app__button--predict:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
        }

        .mnist-app__button--predict:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }

        .mnist-app__results {
            background: linear-gradient(135deg, #f8f9ff, #e6f3ff);
            border-radius: 15px;
            padding: 25px;
            margin-top: 30px;
            box-shadow: inset 0 2px 10px rgba(0, 0, 0, 0.05);
            width: 100%;
            /* 부모 너비에 맞춤 */
        }

        .mnist-app__prediction-result {
            font-size: 1.8rem;
            font-weight: 700;
            color: #333;
            margin-bottom: 20px;
        }

        .mnist-app__confidence-bars {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            max-width: 500px;
            margin: 0 auto;
        }

        .mnist-app__confidence-item {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .mnist-app__digit-label {
            font-size: 1.2rem;
            font-weight: 600;
            color: #333;
            margin-bottom: 8px;
        }

        .mnist-app__confidence-bar {
            width: 40px;
            height: 120px;
            background: #e0e6ed;
            border-radius: 20px;
            position: relative;
            overflow: hidden;
        }

        .mnist-app__confidence-fill {
            position: absolute;
            bottom: 0;
            width: 100%;
            background: linear-gradient(to top, #667eea, #764ba2);
            border-radius: 20px;
            transition: height 0.8s ease;
        }

        .mnist-app__confidence-text {
            font-size: 0.9rem;
            font-weight: 500;
            color: #666;
            margin-top: 5px;
        }

        /* 피드백 영역 스타일 */
        .mnist-app__feedback-section {
            margin-top: 30px; /* .mnist-app__results 와의 간격 */
            padding: 25px;
            background: linear-gradient(135deg, #f8f9ff, #e6f3ff);
            border-radius: 15px;
            box-shadow: inset 0 2px 10px rgba(0, 0, 0, 0.05);
            width: 100%;
            text-align: center;
            display: block; /* 기본적으로 표시 */
        }

        .mnist-app__feedback-section h3 {
            margin-bottom: 20px;
            color: #333;
            font-size: 1.5rem;
        }

        .mnist-app__feedback-controls {
            display: flex;
            flex-direction: row;
            justify-content: center;
            align-items: center;
            gap: 15px;
            flex-wrap: wrap;
        }

        .mnist-app__feedback-select {
            padding: 8px;
            border-radius: 5px;
            border: 1px solid #ccc;
            font-size: 1rem;
        }

        .mnist-app__feedback-button {
            padding: 8px 15px;
            background: linear-gradient(45deg, #ffc107, #ff9800);
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s ease;
            font-size: 1rem;
        }

        .mnist-app__feedback-button:hover {
            background: linear-gradient(45deg, #ffb300, #f57c00);
        }

        .mnist-app__feedback-button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .mnist-app__feedback-info-text {
            text-align: center;
            margin-top: 15px;
            font-size: 0.95rem;
            color: #666;
            line-height: 1.5;
        }

        /* 피드백 메시지 스타일 */
        .mnist-app__feedback-message {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 15px 30px;
            border-radius: 8px;
            z-index: 1000;
            transition: opacity 0.5s ease-in-out, transform 0.5s ease-in-out;
            font-size: 16px;
            font-weight: bold;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            color: white;
            opacity: 0;
            /* 기본적으로 숨김 */
            visibility: hidden;
            /* 기본적으로 숨김 */
        }

        .mnist-app__feedback-message--success {
            background-color: #4CAF50;
        }

        .mnist-app__feedback-message--error {
            background-color: #f44336;
        }

        /* 전처리된 이미지 컨테이너 스타일 */
        .debug-images-container {
            display: flex;
            flex-direction: row;
            flex-wrap: wrap;
            justify-content: center;
            align-items: flex-start;
            gap: 10px;
            margin-top: 0;
            padding: 20px;
            width: 350px;
            height: auto;
            max-height: 400px;
            overflow-y: auto;
            flex-shrink: 0;
            background-color: rgba(255, 255, 255, 0.8);
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            border-top: none;
            border-left: 1px solid #eee;
        }

        .debug-images-container h3 {
            margin-bottom: 15px;
            /* 버튼과의 간격 */
            margin-top: 0;
            /* 상단 불필요한 마진 제거 */
            width: 100%;
            /* 제목 전체 너비 사용 */
            color: #333;
            text-align: center;
            /* 제목 중앙 정렬 */
        }

        /* 히스토리 초기화 버튼 스타일 */
        #clearHistoryBtn {
            margin-bottom: 15px;
            /* 이미지 항목과의 간격 */
            width: auto;
            /* 너비 자동 설정 */
        }

        .history-item {
            border: 1px solid #ddd;
            padding: 5px;
            border-radius: 8px;
            background-color: #fff;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
            display: flex;
            /* 자식(캔버스, 라벨) 정렬 위해 flex */
            flex-direction: column;
            /* 세로 정렬 */
            text-align: center;
            align-items: center;
            /* 아이템 내용 중앙 정렬 */
            width: 80px;
            /* 항목 고정 너비 (28x28 캔버스 + 패딩 고려) */
            flex-basis: 80px;
            /* Flex 항목의 기본 크기 */
            flex-grow: 0;
            /* 커지지 않도록 설정 */
            flex-shrink: 0;
            /* 줄어들지 않도록 설정 */
        }

        .history-item canvas {
            display: block;
            /* 캔버스 아래 공백 제거 */
            margin-bottom: 5px;
            /* 라벨과의 간격 */
        }

        .history-item div {
            font-size: 0.8em;
        }

        /* 반응형 디자인 */
        @media (max-width: 768px) {
            .mnist-app {
                padding: 20px;
            }

            .mnist-app__title {
                font-size: 2rem;
            }

            .mnist-app__drawing-area {
                flex-direction: column;
                align-items: center;
            }

            .mnist-app__canvas-container {
                width: 100%;
                align-items: center;
            }

            .mnist-app__canvas--drawing {
                width: 250px;
                height: 250px;
            }

            .mnist-app__controls {
                flex-direction: row;
                align-items: center;
                justify-content: center;
                gap: 10px;
            }

            .mnist-app__confidence-bars {
                grid-template-columns: repeat(3, 1fr);
            }

            .mnist-app__feedback-controls {
                flex-direction: row;
                justify-content: center;
                align-items: center;
            }

            .mnist-app__feedback-select,
            .mnist-app__feedback-button {
                width: auto;
                margin-right: 0 !important;
            }

            .debug-images-container {
                width: 100%;
                max-width: none;
                height: auto;
                max-height: 300px;
                margin-top: 20px;
                border-top: 1px solid #eee;
                border-left: none;
                order: 1;
            }

            .debug-images-container h3,
            #clearHistoryBtn {
                width: auto;
                margin-left: 10px;
                margin-right: 10px;
            }

            .history-item {
                width: 60px;
                flex-basis: 60px;
            }
        }

        @media (max-width: 480px) {
            .mnist-app__confidence-bars {
                grid-template-columns: repeat(2, 1fr);
                /* 아주 작은 화면에서 2개씩 */
            }
        }
    </style>
</head>

<body>
    <!-- 메인 레이아웃 컨테이너 추가 -->
    <div class="main-layout-container">

        <div class="mnist-app container">
            <h1 class="mnist-app__title"><span>🔢</span> MNIST 손글씨 인식기</h1>

            <div class="mnist-app__instructions">
                <h3>사용법</h3>
                <p>아래 캔버스에 0~9 숫자를 그려보세요. 정밀한 CNN 모델이 숫자를 인식합니다!</p>
            </div>

            <div class="mnist-app__status" id="modelStatus">모델 로딩 중...약 30초 소요</div>

            <!-- 로딩 컨테이너 추가 -->
            <div class="mnist-app__loading-container" id="loadingContainer">
                <div class="mnist-app__progress-text" id="progressText">모델 초기화 중...</div>
                <div class="mnist-app__progress-bar">
                    <div class="mnist-app__progress-fill" id="progressFill"></div>
                </div>
                <div class="mnist-app__loading-spinner"></div>
                <div class="mnist-app__loading-steps">
                    <div class="mnist-app__step" id="step1">1. TensorFlow.js 초기화</div>
                    <div class="mnist-app__step" id="step2">2. 모델 생성</div>
                    <div class="mnist-app__step" id="step3">3. 데이터 준비</div>
                    <div class="mnist-app__step" id="step4">4. 모델 훈련</div>
                </div>
            </div>

            <div class="mnist-app__drawing-area">
                <div class="drawing-and-debug-wrapper"> <!-- 새로운 래퍼 추가 -->
                    <div class="mnist-app__canvas-container">
                        <canvas id="drawingCanvas" class="mnist-app__canvas--drawing" width="280" height="280" role="img"
                            aria-label="숫자 손글씨 입력 영역" title="숫자 손글씨를 그리는 영역입니다."></canvas>
                        <div class="mnist-app__controls">
                            <button class="mnist-app__button mnist-app__button--clear" id="clearBtn" aria-label="캔버스 지우기"
                                title="그림판을 지웁니다.">🗑️ 지우기</button>
                            <button class="mnist-app__button mnist-app__button--predict" id="predictBtn" disabled
                                aria-label="손글씨 인식하기" title="그린 손글씨를 인공지능으로 인식합니다.">🔍 인식하기</button>
                        </div>
                    </div>

                    <!-- 전처리된 이미지 컨테이너를 여기로 이동 -->
                    <div id="debugImagesContainer" class="debug-images-container">
                        <h3>전처리된 이미지 확인 (디버깅용)</h3>
                        <button id="clearHistoryBtn" class="mnist-app__button mnist-app__button--clear"
                            style="margin-bottom: 15px; width: auto;">히스토리 초기화</button>
                        <!-- 히스토리 아이템들은 JavaScript로 여기에 추가됩니다 -->
                    </div>
                </div>

                <div class="mnist-app__feedback-section">
                    <h3>이 숫자가 맞나요?</h3>
                    
                    <div class="mnist-app__feedback-controls">
                        <select id="correctDigit" class="mnist-app__feedback-select" aria-label="정답 숫자 선택"
                            title="인공지능 예측이 틀렸을 경우 올바른 숫자를 선택하여 피드백합니다.">
                            <option value="-1">선택하세요</option>
                            <option value="0">0</option>
                            <option value="1">1</option>
                            <option value="2">2</option>
                            <option value="3">3</option>
                            <option value="4">4</option>
                            <option value="5">5</option>
                            <option value="6">6</option>
                            <option value="7">7</option>
                            <option value="8">8</option>
                            <option value="9">9</option>
                        </select>
                        <button id="sendFeedbackBtn" class="mnist-app__feedback-button">피드백 보내기</button>
                    </div>
                    <div class="mnist-app__feedback-info-text">
                        잘못된 피드백, 틀린 숫자를 라벨링하는 경우가 있어, <br>매일 숫자데이터는 초기화 됩니다.
                    </div>
                </div>
            </div>

            <div class="mnist-app__results" id="results" style="display: none;">
                <div class="mnist-app__prediction-result" id="predictionResult">예측 결과</div>
                <div class="mnist-app__confidence-bars">
                    <div class="mnist-app__confidence-item">
                        <div class="mnist-app__digit-label">0</div>
                        <div class="mnist-app__confidence-bar">
                            <div class="mnist-app__confidence-fill" id="conf-0"></div>
                        </div>
                        <div class="mnist-app__confidence-text" id="conf-text-0">0%</div>
                    </div>
                    <div class="mnist-app__confidence-item">
                        <div class="mnist-app__digit-label">1</div>
                        <div class="mnist-app__confidence-bar">
                            <div class="mnist-app__confidence-fill" id="conf-1"></div>
                        </div>
                        <div class="mnist-app__confidence-text" id="conf-text-1">0%</div>
                    </div>
                    <div class="mnist-app__confidence-item">
                        <div class="mnist-app__digit-label">2</div>
                        <div class="mnist-app__confidence-bar">
                            <div class="mnist-app__confidence-fill" id="conf-2"></div>
                        </div>
                        <div class="mnist-app__confidence-text" id="conf-text-2">0%</div>
                    </div>
                    <div class="mnist-app__confidence-item">
                        <div class="mnist-app__digit-label">3</div>
                        <div class="mnist-app__confidence-bar">
                            <div class="mnist-app__confidence-fill" id="conf-3"></div>
                        </div>
                        <div class="mnist-app__confidence-text" id="conf-text-3">0%</div>
                    </div>
                    <div class="mnist-app__confidence-item">
                        <div class="mnist-app__digit-label">4</div>
                        <div class="mnist-app__confidence-bar">
                            <div class="mnist-app__confidence-fill" id="conf-4"></div>
                        </div>
                        <div class="mnist-app__confidence-text" id="conf-text-4">0%</div>
                    </div>
                    <div class="mnist-app__confidence-item">
                        <div class="mnist-app__digit-label">5</div>
                        <div class="mnist-app__confidence-bar">
                            <div class="mnist-app__confidence-fill" id="conf-5"></div>
                        </div>
                        <div class="mnist-app__confidence-text" id="conf-text-5">0%</div>
                    </div>
                    <div class="mnist-app__confidence-item">
                        <div class="mnist-app__digit-label">6</div>
                        <div class="mnist-app__confidence-bar">
                            <div class="mnist-app__confidence-fill" id="conf-6"></div>
                        </div>
                        <div class="mnist-app__confidence-text" id="conf-text-6">0%</div>
                    </div>
                    <div class="mnist-app__confidence-item">
                        <div class="mnist-app__digit-label">7</div>
                        <div class="mnist-app__confidence-bar">
                            <div class="mnist-app__confidence-fill" id="conf-7"></div>
                        </div>
                        <div class="mnist-app__confidence-text" id="conf-text-7">0%</div>
                    </div>
                    <div class="mnist-app__confidence-item">
                        <div class="mnist-app__digit-label">8</div>
                        <div class="mnist-app__confidence-bar">
                            <div class="mnist-app__confidence-fill" id="conf-8"></div>
                        </div>
                        <div class="mnist-app__confidence-text" id="conf-text-8">0%</div>
                    </div>
                    <div class="mnist-app__confidence-item">
                        <div class="mnist-app__digit-label">9</div>
                        <div class="mnist-app__confidence-bar">
                            <div class="mnist-app__confidence-fill" id="conf-9"></div>
                        </div>
                        <div class="mnist-app__confidence-text" id="conf-text-9">0%</div>
                    </div>
                </div>
            </div>
        </div>

    </div> <!-- .main-layout-container 닫는 태그 -->

    <!-- 피드백/오류 메시지 표시 영역 -->
    <div id="systemMessage" class="mnist-app__feedback-message" role="alert"></div>

    <script>
        // ===============================================
        // 전역 변수 및 초기 설정
        // ===============================================
        const canvas = document.getElementById('drawingCanvas');
        const ctx = canvas.getContext('2d');
        let isDrawing = false;
        let modelReady = false; // 서버 모델 준비 상태

        // Canvas 스타일 설정
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 12;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';

        // History 관리를 위한 클래스 추가
        class HistoryManager {
            constructor() {
                this.history = [];
                this.container = document.getElementById('debugImagesContainer'); // 이제 HTML에 직접 있음
                this.storageKey = 'mnist_history'; // Local Storage 키 설정
                this.maxHistoryItems = 20; // 최대 저장 개수 설정 (예: 20개)
            }

            // Local Storage에서 히스토리 불러오기
            async loadHistory() {
                const storedHistory = localStorage.getItem(this.storageKey);
                if (storedHistory) {
                    try {
                        const parsedHistory = JSON.parse(storedHistory);
                        const loadedItems = []; // 불러온 유효 항목들을 담을 배열

                        // 기존 렌더링된 항목 지우기 (loadHistory는 모든 항목을 다시 그림)
                        if (this.container) {
                            while (this.container.children.length > 1) { // 첫 번째 자식(h3) 제외
                                this.container.removeChild(this.container.lastChild);
                            }
                        }

                        // 불러온 각 항목의 Base64 URL을 ImageData 객체로 변환
                        for (const item of parsedHistory) { // 비동기를 위해 for...of 사용
                            if (!item.imageDataUrl) continue; // 이미지 데이터 없으면 건너뛰기

                            const img = new Image();
                            img.src = item.imageDataUrl; // 저장된 Base64 URL 사용

                            try {
                                // 이미지가 로드될 때까지 기다립니다.
                                await new Promise((resolve, reject) => {
                                    img.onload = resolve;
                                    img.onerror = (e) => { // 오류 처리 추가
                                        console.warn('히스토리 이미지 로드 실패, 항목 건너뛰기', item.timestamp, e);
                                        resolve(); // 오류 발생 시에도 resolve 호출하여 계속 진행
                                    };
                                });

                                if (!img.naturalWidth || !img.naturalHeight) { // 이미지 로드 실패 확인
                                    console.warn('히스토리 이미지 로드 실패 (empty image), 항목 건너뛰기', item.timestamp);
                                    continue; // 유효하지 않은 이미지 건너뛰기
                                }

                                const canvas = document.createElement('canvas');
                                canvas.width = img.width; // 이미지 실제 너비 사용
                                canvas.height = img.height; // 이미지 실제 높이 사용
                                const ctx = canvas.getContext('2d');

                                ctx.drawImage(img, 0, 0); // 이미지 그리기
                                const imageData = ctx.getImageData(0, 0, img.width, img.height); // ImageData 가져오기

                                // 원본 항목의 다른 속성과 함께 ImageData 저장
                                loadedItems.push({ ...item, imageData: imageData });

                            } catch (e) {
                                console.error('히스토리 이미지 렌더링 중 오류 발생', item.timestamp, e);
                                // 오류 발생 시 해당 항목은 히스토리에 추가하지 않음
                            }
                        }

                        this.history = loadedItems; // 유효한 항목들로 히스토리 배열 업데이트
                        console.log(`Local Storage에서 ${this.history.length}개의 유효한 히스토리 항목을 불러왔습니다.`);

                        // 불러온 모든 항목을 화면에 다시 렌더링
                        this.renderAllHistoryItems();

                    } catch (e) {
                        console.error('Local Storage 히스토리 구문 분석 오류:', e);
                        localStorage.removeItem(this.storageKey); // 파싱 오류 시 데이터 삭제
                        this.history = []; // 히스토리 초기화
                    }
                } else {
                    console.log('Local Storage에서 히스토리 데이터를 찾을 수 없습니다.');
                    this.history = []; // 저장된 히스토리가 없으면 빈 배열로 초기화
                }
            }

            // 히스토리 항목 전체를 DOM에 렌더링하는 함수 추가
            renderAllHistoryItems() {
                if (this.container) {
                    // 기존 렌더링된 항목 모두 지우기 (h3 태그 제외)
                    while (this.container.children.length > 1) {
                        this.container.removeChild(this.container.lastChild);
                    }
                    // 현재 히스토리 배열의 모든 항목 다시 그리기
                    this.history.forEach(item => this.renderHistoryItem(item));
                    console.log('모든 히스토리 항목 다시 렌더링 완료.');
                } else {
                    console.error('HistoryManager: debugImagesContainer를 찾을 수 없습니다. 히스토리를 렌더링할 수 없습니다.');
                }
            }

            renderHistoryItem(item) {
                // loadHistory와 addImage 모두에서 호출 가능. 실제 DOM 추가 및 이미지 그림.
                // 전달받은 item 객체는 반드시 imageData 속성을 가져야 함.

                if (!item.imageData || !(item.imageData instanceof ImageData)) { // ImageData 객체인지 명시적 확인
                    console.error('renderHistoryItem: 유효한 ImageData 객체가 없어 렌더링할 수 없습니다.', item);
                    return; // 유효한 ImageData 없으면 렌더링하지 않음
                }

                const imgWrapper = document.createElement('div');
                imgWrapper.className = 'history-item';

                const canvas = document.createElement('canvas');
                canvas.width = item.imageData.width; // ImageData의 실제 크기 사용
                canvas.height = item.imageData.height; // ImageData의 실제 크기 사용
                const ctx = canvas.getContext('2d');
                // ImageData 객체를 캔버스에 그립니다.
                ctx.putImageData(item.imageData, 0, 0);

                const label = document.createElement('div');
                label.textContent = `${item.type === 'prediction' ? '예측' : '피드백'}: ${item.label}`;
                label.style.color = item.type === 'prediction' ? '#667eea' : '#16a34a'; // CSS에서 처리

                imgWrapper.appendChild(canvas);
                imgWrapper.appendChild(label);

                if (this.container) {
                    // 새 항목을 항상 컨테이너의 맨 뒤에 추가하여 시간순으로 정렬
                    this.container.appendChild(imgWrapper);
                } else {
                    console.error('HistoryManager: debugImagesContainer를 찾을 수 없습니다. 히스토리를 렌더링할 수 없습니다.');
                }
            }

            addImage(imageData, label, type = 'prediction') {
                const historyItem = {
                    imageData,
                    label,
                    type,
                    timestamp: new Date().toISOString()
                };

                // 새 항목을 배열의 끝에 추가
                this.history.push(historyItem);

                // 최대 개수 초과 시 오래된 항목 제거
                while (this.history.length > this.maxHistoryItems) {
                    const oldestItem = this.history.shift();
                    console.log('히스토리 최대 개수 초과, 가장 오래된 항목 제거됨.', oldestItem.timestamp);
                }

                // Local Storage 저장 (변경 사항 반영) - ImageData를 Base64로 변환하여 저장
                this.saveHistory();
                this.renderAllHistoryItems();
            }

            // 히스토리 Local Storage에 저장 함수 추가
            saveHistory() {
                try {
                    const historyToStore = this.history.map(item => ({
                        imageDataUrl: this.imageDataToBase64(item.imageData),
                        label: item.label,
                        type: item.type,
                        timestamp: item.timestamp
                    }));
                    localStorage.setItem(this.storageKey, JSON.stringify(historyToStore));
                } catch (e) {
                    console.error('Failed to save history to Local Storage:', e);
                }
            }

            // ImageData 객체를 Base64 Data URL로 변환하는 헬퍼 함수
            imageDataToBase64(imageData) {
                const canvas = document.createElement('canvas');
                canvas.width = imageData.width;
                canvas.height = imageData.height;
                const ctx = canvas.getContext('2d');
                ctx.putImageData(imageData, 0, 0);
                return canvas.toDataURL('image/png');
            }

            clear() {
                this.history = [];
                if (this.container) {
                    while (this.container.children.length > 1) {
                        this.container.removeChild(this.container.lastChild);
                    }
                }
                // Local Storage에서도 히스토리 제거 후 저장 (clear에서도 saveHistory 호출)
                this.saveHistory();
                console.log('History cleared from memory and Local Storage.');
            }
        } // HistoryManager 클래스 정의 닫기

        // 전역 히스토리 매니저 인스턴스 생성 (HistoryManager 클래스 정의 후)
        const historyManager = new HistoryManager();

        // 브라우저 뒤로가기 시 정리 (TensorFlow.js 메모리 정리, 유지)
        window.addEventListener('beforeunload', () => {
            if (typeof tf !== 'undefined') {
                tf.disposeVariables();
            }
        });

        // 필기체 스타일 랜덤 곡선 함수 (캔버스 그리기용, 유지)
        function drawHandwrittenCurve(ctx, points) {
            ctx.beginPath();
            ctx.moveTo(points[0][0], points[0][1]);
            for (let i = 1; i < points.length; i++) {
                const [x, y] = points[i];
                ctx.lineTo(x + (Math.random() - 0.5) * 2, y + (Math.random() - 0.5) * 2);
            }
            ctx.stroke();
        }

        // 데이터 증강 함수 (이제 클라이언트 전처리용, 유지)
        function augmentData(image) {
            const augmented = tf.tidy(() => {
                // 랜덤 회전 (-15도 ~ 15도)
                const rotation = tf.image.rotateWithOffset(image, (Math.random() - 0.5) * 0.3);

                // 랜덤 확대/축소 (0.9 ~ 1.1)
                const scale = 0.9 + Math.random() * 0.2;
                const scaled = tf.image.resizeBilinear(rotation, [28, 28]);

                return scaled;
            });
            return augmented;
        }

        // 이미지 전처리 함수 (클라이언트 전처리용, 유지)
        function preprocessCanvas() {
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;

            // 경계 박스 찾기
            let minX = canvas.width, minY = canvas.height, maxX = 0, maxY = 0;
            let hasContent = false;

            for (let y = 0; y < canvas.height; y++) {
                for (let x = 0; x < canvas.width; x++) {
                    const alpha = data[(y * canvas.width + x) * 4 + 3];
                    if (alpha > 10) { // 투명도가 10보다 크면 내용으로 간주
                        hasContent = true;
                        minX = Math.min(minX, x);
                        minY = Math.min(minY, y);
                        maxX = Math.max(maxX, x);
                        maxY = Math.max(maxY, y);
                    }
                }
            }

            // 캔버스가 비어 있으면 null 또는 특정 값 반환하여 예측 방지
            if (!hasContent) {
                console.log('preprocessCanvas: 캔버스에 내용이 없습니다.');
                return null; // 내용이 없음을 나타내기 위해 null 반환
            }

            // 여백 추가 및 정규화
            const padding = 20;
            minX = Math.max(0, minX - padding);
            minY = Math.max(0, minY - padding);
            maxX = Math.min(canvas.width, maxX + padding);
            maxY = Math.min(canvas.height, maxY + padding);

            const boundingWidth = maxX - minX;
            const boundingHeight = maxY - minY;
            const maxDim = Math.max(boundingWidth, boundingHeight);

            // 정사각형으로 크롭
            const centerX = (minX + maxX) / 2;
            const centerY = (minY + maxY) / 2;
            const cropX = centerX - maxDim / 2;
            const cropY = centerY - maxDim / 2;

            // 28x28로 리사이즈
            const resizeCanvas = document.createElement('canvas');
            resizeCanvas.width = 28;
            resizeCanvas.height = 28;
            const resizeCtx = resizeCanvas.getContext('2d');

            resizeCtx.fillStyle = 'white';
            resizeCtx.fillRect(0, 0, 28, 28);
            resizeCtx.drawImage(canvas, cropX, cropY, maxDim, maxDim, 0, 0, 28, 28);

            // 텐서로 변환 및 정규화
            const resizedImageData = resizeCtx.getImageData(0, 0, 28, 28);
            const resizedData = resizedImageData.data;
            const input = new Float32Array(28 * 28);

            for (let i = 0; i < 28 * 28; i++) {
                const pixelIndex = i * 4;
                const gray = (resizedData[pixelIndex] + resizedData[pixelIndex + 1] + resizedData[pixelIndex + 2]) / 3;
                input[i] = (255 - gray) / 255; // 0-1 범위로 정규화 및 색상 반전 (어두운 배경 0, 밝은 글씨 1)
            }

            // 데이터 증강 적용 (예측 시점에는 적용하지 않음)
            const tensor = tf.tensor4d(input, [1, 28, 28, 1]); // [Batch size, Height, Width, Channels]
            return tensor; // 증강 없이 원본 텐서 반환
        }

        // 모델 불러오기 또는 새로 학습 (이제 서버 상태 확인 시작 역할, 함수명 유지)
        async function loadOrCreateModel() {
            if (typeof tf !== 'undefined' && !tf.ready) {
                await tf.ready();
            }
            console.log('TensorFlow.js 초기화 완료 (클라이언트 전처리용).');
        }

        // 터치 및 마우스 이벤트 처리 (유지)
        function getTouchPos(e) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;

            if (e.touches && e.touches[0]) {
                return {
                    x: (e.touches[0].clientX - rect.left) * scaleX,
                    y: (e.touches[0].clientY - rect.top) * scaleY
                };
            } else {
                return {
                    x: (e.clientX - rect.left) * scaleX,
                    y: (e.clientY - rect.top) * scaleY
                };
            }
        }

        // 시스템 메시지(성공/오류) 표시 함수 (유지)
        function showSystemMessage(message, type) {
            const messageElement = document.getElementById('systemMessage');
            if (!messageElement) return; // 요소 없으면 중단

            messageElement.textContent = message;
            messageElement.className = 'mnist-app__feedback-message'; // 기본 클래스로 초기화
            messageElement.classList.add(`mnist-app__feedback-message--${type}`); // 타입별 클래스 추가

            messageElement.style.opacity = '1';
            messageElement.style.visibility = 'visible';
            messageElement.style.transform = 'translateX(-50%) translateY(0px)';

            // 5초 후 메시지 사라지게 하기
            setTimeout(() => {
                messageElement.style.opacity = '0';
                messageElement.style.transform = 'translateX(-50%) translateY(-10px)';
                setTimeout(() => {
                    messageElement.style.visibility = 'hidden'; // 완전히 숨김
                }, 500); // opacity transition 시간과 일치
            }, 5000); // 메시지 표시 시간 (5초)
        }


        // 모델 초기화 (이제 서버 상태 확인 및 UI 업데이트 역할)
        async function initServerStatusCheck() {
            const statusElement = document.getElementById('modelStatus');
            const progressFill = document.getElementById('progressFill');
            const progressText = document.getElementById('progressText');
            const loadingContainer = document.getElementById('loadingContainer');
            const predictBtn = document.getElementById('predictBtn');

            // 초기 상태 설정
            statusElement.textContent = '서버 연결 중...';
            statusElement.className = 'mnist-app__status mnist-app__status--loading'; // CSS 클래스에 맞게 수정
            progressFill.style.width = '0%';
            progressText.textContent = '서버 응답 대기 중...(약 30초 소요)';
            const loadingSteps = document.querySelector('.mnist-app__loading-steps');
            if (loadingSteps) loadingSteps.style.display = 'none';

            if (predictBtn) predictBtn.disabled = true; // 서버 준비될 때까지 버튼 비활성화

            // 서버 상태 확인을 위한 URL (예측 엔드포인트 사용)
            const serverStatusUrl = 'https://tjdgus1121-github-io.onrender.com/'; // 서버 기본 경로로 변경
            let retryCount = 0;
            const maxRetries = 10; // 최대 재시도 횟수
            const retryDelay = 3000; // 재시도 간격 (밀리초)

            while (retryCount < maxRetries) {
                try {
                    console.log(`서버 상태 확인 시도 ${retryCount + 1}/${maxRetries}: ${serverStatusUrl}`);
                    // 서버 기본 경로에 HEAD 요청 보내기
                    const response = await fetch(serverStatusUrl, { method: 'HEAD' });

                    if (response.ok) { // 200 OK 응답만 성공으로 간주
                        console.log('서버 예측 엔드포인트 응답 확인.');
                        statusElement.textContent = '서버 준비 완료! 사용 가능.';
                        statusElement.className = 'mnist-app__status mnist-app__status--ready'; // CSS 클래스에 맞게 수정
                        progressFill.style.width = '100%';
                        progressText.textContent = '모든 기능 사용 가능';
                        if (predictBtn) predictBtn.disabled = false; // 서버 준비 완료 시 버튼 활성화

                        // 로딩 컨테이너 숨기기
                        setTimeout(() => {
                            if (loadingContainer) loadingContainer.style.display = 'none';
                        }, 1000);

                        modelReady = true; // 서버 준비 완료 상태 변수
                        return; // 성공적으로 연결되면 함수 종료
                    }

                    console.warn(`서버 상태 확인 응답 코드: ${response.status}. 재시도...`);

                } catch (error) {
                    console.error(`서버 상태 확인 실패: ${error}. 재시도...`);
                }

                retryCount++;
                if (progressFill) progressFill.style.width = `${(retryCount / maxRetries) * 100}%`;
                if (progressText) progressText.textContent = `서버 연결 실패. 재시도 중... (${retryCount}/${maxRetries})`;
                await new Promise(resolve => setTimeout(resolve, retryDelay)); // 지연 후 재시도
            }

            // 최대 재시도 후에도 연결 실패
            console.error('서버 연결에 실패했습니다. 나중에 다시 시도해주세요.');
            if (statusElement) {
                statusElement.textContent = '서버 연결 실패. 나중에 다시 시도하세요.';
                statusElement.style.color = '#ef4444';
                statusElement.className = 'mnist-app__status'; // 기본 상태 클래스로 초기화
            }
            if (progressText) progressText.textContent = '서버에 연결할 수 없습니다.';
            if (progressFill) progressFill.style.background = '#ef4444';
            if (predictBtn) predictBtn.disabled = true; // 연결 실패 시 버튼 비활성화 유지
            modelReady = false; // 서버 준비 안 됨 상태
        }

        // Canvas 지우기
        function clearCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            // 예측 결과 및 피드백 영역 숨김
            const resultsDiv = document.getElementById('results');
            if (resultsDiv) resultsDiv.style.display = 'none';
        }

        // 서버로 이미지 전송 및 예측 결과 받기
        async function predictWithServer() {
            if (!modelReady) {
                showSystemMessage('서버가 아직 준비되지 않았습니다. 잠시 후 다시 시도해주세요.', 'error');
                return;
            }

            // 빈 캔버스 체크
            const processedTensor = preprocessCanvas(); // preprocessCanvas에서 null 반환 시 그림 없음
            if (processedTensor === null) {
                showSystemMessage('숫자를 그려주세요!', 'error');
                return;
            }

            let imgArray = null; // try 블록 외부에서 선언하여 finally에서 dispose 가능하게 함
            let flatArray = null;
            let grayScalePixels = null;
            let imgData = null;
            let predictedDigit = null;
            let probabilities = null;

            try {
                imgArray = await processedTensor.array();

                flatArray = imgArray[0].flat();
                grayScalePixels = new Uint8ClampedArray(28 * 28 * 4);

                for (let i = 0; i < 28 * 28; i++) {
                    const gray = Math.round((1 - flatArray[i]) * 255);
                    grayScalePixels[i * 4 + 0] = gray;
                    grayScalePixels[i * 4 + 1] = gray;
                    grayScalePixels[i * 4 + 2] = gray;
                    grayScalePixels[i * 4 + 3] = 255;
                }

                imgData = new ImageData(grayScalePixels, 28, 28);
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = 28;
                tempCanvas.height = 28;
                const tempCtx = tempCanvas.getContext('2d');
                tempCtx.putImageData(imgData, 0, 0);

                const imgDataUrl = tempCanvas.toDataURL('image/png');
                let imgBase64 = imgDataUrl.split(',')[1];

                // 예측 요청을 /predict 엔드포인트로 보내도록 URL 수정
                const serverUrl = 'https://tjdgus1121-github-io.onrender.com/predict';

                const response = await fetch(serverUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    // /predict 엔드포인트는 일반적으로 이미지 데이터만 필요하므로 label 제거
                    body: JSON.stringify({ image: imgBase64 })
                });

                if (!response.ok) {
                    // 서버 응답 상태 코드가 200번대가 아닌 경우
                    const errorText = await response.text(); // 서버에서 보낸 오류 응답 본문 읽기
                    throw new Error(`HTTP error! status: ${response.status}. Details: ${errorText}`);
                }

                const result = await response.json();

                // 서버 응답 유효성 검사: predictedDigit 및 probabilities 필드 확인
                if (typeof result.result === 'undefined' || !Array.isArray(result.probs) || result.probs.length !== 10) {
                    console.error('Invalid server response format:', result);
                    throw new Error('서버 응답 형식이 올바르지 않습니다.'); // 예상치 못한 응답 형식에 대한 오류 throw
                }

                const imgArrayForHistory = await processedTensor.array(); // 텐서에서 다시 배열 얻기
                const flatArrayForHistory = imgArrayForHistory[0].flat();
                const grayScalePixelsForHistory = new Uint8ClampedArray(28 * 28 * 4);

                for (let i = 0; i < 28 * 28; i++) {
                    const gray = Math.round((1 - flatArrayForHistory[i]) * 255);
                    grayScalePixelsForHistory[i * 4 + 0] = gray;
                    grayScalePixelsForHistory[i * 4 + 1] = gray;
                    grayScalePixelsForHistory[i * 4 + 2] = gray;
                    grayScalePixelsForHistory[i * 4 + 3] = 255; // 완전 불투명
                }

                const imgDataForHistory = new ImageData(grayScalePixelsForHistory, 28, 28);

                historyManager.addImage(imgDataForHistory, result.result, 'prediction');

                // 성공 메시지 표시 (화면 상단 메시지 사용)
                showSystemMessage(result.message || '예측이 성공적으로 완료되었습니다!', 'success');

                predictedDigit = result.result;
                probabilities = result.probs;

            } catch (error) {
                console.error('예측 실행 중 오류:', error);
                // 오류 메시지 표시 (화면 상단 메시지 사용)
                showSystemMessage(`예측 실행 중 오류가 발생했습니다: ${error.message}. 서버 상태를 확인해주세요.`, 'error');

            } finally {
                // TensorFlow.js Tensor 메모리 정리
                if (processedTensor) processedTensor.dispose();

                if (typeof predictedDigit !== 'undefined' && Array.isArray(probabilities) && probabilities.length === 10) {
                    showPredictionResult(predictedDigit, probabilities);
                } else if (typeof predictedDigit !== 'undefined') {
                    // 확률값은 없지만 예측 숫자는 받은 경우 (서버 오류 등)
                    showPredictionResult(predictedDigit, new Array(10).fill(0)); // 확률값은 0으로 채워 표시
                } else {
                    // 예측 숫자도 받지 못한 경우
                    showPredictionResult('알 수 없음', new Array(10).fill(0)); // 기본 결과 표시
                }

                // 예측 버튼 다시 활성화 및 텍스트 복원
                const predictBtn = document.getElementById('predictBtn');
                if (predictBtn) {
                    predictBtn.disabled = false;
                    predictBtn.textContent = '🔍 인식하기';
                }
            }
        }

        // 예측 결과 표시 함수 (유지 - predictWithServer 아래로 이동하여 관련 로직과 가깝게 배치)
        function showPredictionResult(predictedDigit, probabilities) {
            const resultsDiv = document.getElementById('results');
            const predictionResult = document.getElementById('predictionResult');
            if (predictionResult) { // null 체크 추가
                predictionResult.innerHTML = `예측: <strong style="color: #667eea; font-size: 2rem;">${predictedDigit}</strong>`;
            }

            // 신뢰도 막대 업데이트
            for (let i = 0; i < 10; i++) {
                const fillElement = document.getElementById(`conf-${i}`);
                const textElement = document.getElementById(`conf-text-${i}`);
                if (fillElement && textElement) { // null 체크 추가
                    const percentage = (probabilities[i] * 100).toFixed(1);
                    fillElement.style.height = `${probabilities[i] * 100}%`;
                    textElement.textContent = `${percentage}%`;
                    if (i === predictedDigit) {
                        fillElement.style.background = 'linear-gradient(to top, #ff6b6b, #ee5a24)';
                    } else {
                        fillElement.style.background = 'linear-gradient(to top, #667eea, #764ba2)';
                    }
                }
            }
            if (resultsDiv) {
                resultsDiv.style.display = 'block';
            }
        }

        // 이벤트 리스너 설정

        window.addEventListener('load', async () => {

            await initServerStatusCheck();

            await historyManager.loadHistory();

            // 마우스 이벤트
            canvas.addEventListener('mousedown', (e) => {
                isDrawing = true;
                const pos = getTouchPos(e);
                ctx.beginPath();
                ctx.moveTo(pos.x, pos.y);
            });

            canvas.addEventListener('mousemove', (e) => {
                if (!isDrawing) return;
                const pos = getTouchPos(e);
                ctx.lineTo(pos.x, pos.y);
                ctx.stroke();
            });

            canvas.addEventListener('mouseup', () => {
                isDrawing = false;
            });

            canvas.addEventListener('mouseout', () => {
                isDrawing = false;
            });

            // 터치 이벤트
            canvas.addEventListener('touchstart', (e) => {
                e.preventDefault();
                isDrawing = true;
                const pos = getTouchPos(e);
                ctx.beginPath();
                ctx.moveTo(pos.x, pos.y);
            });

            canvas.addEventListener('touchmove', (e) => {
                e.preventDefault();
                if (!isDrawing) return;
                const pos = getTouchPos(e);
                ctx.lineTo(pos.x, pos.y);
                ctx.stroke();
            });

            canvas.addEventListener('touchend', (e) => {
                e.preventDefault();
                isDrawing = false;
            });

            canvas.addEventListener('touchcancel', (e) => {
                e.preventDefault();
                isDrawing = false;
            });

            // 키보드 단축키
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && modelReady) {
                    // 예측 버튼 클릭 이벤트 트리거
                    const predictBtn = document.getElementById('predictBtn');
                    if (predictBtn && !predictBtn.disabled) {
                        predictBtn.click();
                    }
                } else if (e.key === 'Escape' || e.key === 'Delete') {
                    // ESC 또는 Delete 키로 캔버스만 지우기 (히스토리는 유지)
                    clearCanvas();
                } else if (e.key === 'Backspace') {
                    // Backspace 키로 히스토리까지 모두 지우기
                    historyManager.clear();
                    clearCanvas(); // 캔버스도 함께 지우기
                }
            });

            const clearBtn = document.getElementById('clearBtn');
            if (clearBtn) {
                clearBtn.addEventListener('click', clearCanvas);
            }

            const predictBtn = document.getElementById('predictBtn');
            if (predictBtn) {
                predictBtn.addEventListener('click', async () => {
                    // 예측 로직 실행
                    try {
                        predictBtn.disabled = true;
                        predictBtn.textContent = '인식 중...';

                        await predictWithServer();
                    } catch (error) {
                        console.error('예측 실행 중 오류:', error);
                        // 오류 메시지는 predictWithServer 내부에서 처리
                    } finally {
                    }
                });
            }

            const sendFeedbackBtn = document.getElementById('sendFeedbackBtn');
            if (sendFeedbackBtn) {
                sendFeedbackBtn.addEventListener('click', async (event) => {
                    event.preventDefault();
                    event.stopPropagation();

                    const correctDigitSelect = document.getElementById('correctDigit');
                    const correctDigit = parseInt(correctDigitSelect.value);
                    if (correctDigit >= 0 && correctDigit <= 9) {
                        // 버튼 상태 변경은 sendFeedbackToServer 내부에서 처리
                        try {
                            await sendFeedbackToServer(correctDigit);
                        } catch (error) {
                            console.error('피드백 전송 중 오류:', error);
                            // 오류 메시지는 sendFeedbackToServer 내부에서 처리
                        }
                    } else {
                        showSystemMessage('정답 숫자를 선택해주세요.', 'error'); // alert 대신 화면 메시지 사용
                    }
                });
            }

            // 히스토리 초기화 버튼 이벤트 리스너 추가
            const clearHistoryBtn = document.getElementById('clearHistoryBtn');
            if (clearHistoryBtn) {
                clearHistoryBtn.addEventListener('click', () => {
                    historyManager.clear();
                    // 히스토리 초기화 알림 메시지 표시
                    showSystemMessage('히스토리가 초기화되었습니다.', 'success');
                });
            }
        });

    </script>
</body>

</html>
